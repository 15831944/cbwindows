// Color.cpp
//
// Copyright (c) 1994-2020 By Dale L. Larson, All Rights Reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

#include    "stdafx.h"
#include    <math.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

////////////////////////////////////////////////////////////////////////
// Precalculated color wash table. Only the entries outside of the
// system identity palette are given.

static const BYTE palWash[][3] =
{
    { 0x00, 0x00, 0x01 },   // was 00, 00, 00
    { 0x1C, 0x1C, 0x1C },
    { 0x38, 0x38, 0x38 },
    { 0x55, 0x55, 0x55 },
    { 0x71, 0x71, 0x71 },
    { 0x8D, 0x8D, 0x8D },
    { 0xAA, 0xAA, 0xAA },
    { 0xC6, 0xC6, 0xC6 },
    { 0xE2, 0xE2, 0xE2 },
    { 0xFF, 0xFF, 0xFE },   // was FF, FF, FF
    { 0x33, 0x00, 0x00 },
    { 0x66, 0x00, 0x00 },
    { 0x98, 0x00, 0x00 },
    { 0xCC, 0x00, 0x00 },
    { 0xFF, 0x00, 0x00 },
    { 0xFF, 0x2A, 0x2A },
    { 0xFF, 0x55, 0x55 },
    { 0xFF, 0x7F, 0x7F },
    { 0xFF, 0xAA, 0xAA },
    { 0xFF, 0xD4, 0xD4 },
    { 0x33, 0x10, 0x00 },
    { 0x66, 0x20, 0x00 },
    { 0x98, 0x30, 0x00 },
    { 0xCC, 0x40, 0x00 },
    { 0xFF, 0x50, 0x00 },
    { 0xFF, 0x6D, 0x2A },
    { 0xFF, 0x8A, 0x55 },
    { 0xFF, 0xA7, 0x7F },
    { 0xFF, 0xC4, 0xAA },
    { 0xFF, 0xE1, 0xD4 },
    { 0x33, 0x20, 0x00 },
    { 0x66, 0x40, 0x00 },
    { 0x98, 0x60, 0x00 },
    { 0xCC, 0x80, 0x00 },
    { 0xFF, 0xA0, 0x00 },
    { 0xFF, 0xB0, 0x2A },
    { 0xFF, 0xC0, 0x55 },
    { 0xFF, 0xCF, 0x7F },
    { 0xFF, 0xDF, 0xAA },
    { 0xFF, 0xEF, 0xD4 },
    { 0x33, 0x30, 0x00 },
    { 0x66, 0x60, 0x00 },
    { 0x98, 0x90, 0x00 },
    { 0xCC, 0xC0, 0x00 },
    { 0xFF, 0xF0, 0x00 },
    { 0xFF, 0xF3, 0x2A },
    { 0xFF, 0xF5, 0x55 },
    { 0xFF, 0xF7, 0x7F },
    { 0xFF, 0xFA, 0xAA },
    { 0xFF, 0xFC, 0xD4 },
    { 0x25, 0x33, 0x00 },
    { 0x4B, 0x66, 0x00 },
    { 0x71, 0x98, 0x00 },
    { 0x97, 0xCC, 0x00 },
    { 0xBC, 0xFF, 0x00 },
    { 0xC7, 0xFF, 0x2A },
    { 0xD2, 0xFF, 0x55 },
    { 0xDD, 0xFF, 0x7F },
    { 0xE8, 0xFF, 0xAA },
    { 0xF3, 0xFF, 0xD4 },
    { 0x15, 0x33, 0x00 },
    { 0x2B, 0x66, 0x00 },
    { 0x41, 0x98, 0x00 },
    { 0x56, 0xCC, 0x00 },
    { 0x6C, 0xFF, 0x00 },
    { 0x84, 0xFF, 0x2A },
    { 0x9D, 0xFF, 0x55 },
    { 0xB5, 0xFF, 0x7F },
    { 0xCE, 0xFF, 0xAA },
    { 0xE6, 0xFF, 0xD4 },
    { 0x05, 0x33, 0x00 },
    { 0x0B, 0x66, 0x00 },
    { 0x10, 0x98, 0x00 },
    { 0x16, 0xCC, 0x00 },
    { 0x1C, 0xFF, 0x00 },
    { 0x41, 0xFF, 0x2A },
    { 0x67, 0xFF, 0x55 },
    { 0x8D, 0xFF, 0x7F },
    { 0xB3, 0xFF, 0xAA },
    { 0xD9, 0xFF, 0xD4 },
    { 0x28, 0x33, 0x0A },
    { 0x51, 0x66, 0x14 },
    { 0x79, 0x98, 0x1F },
    { 0xA2, 0xCC, 0x29 },
    { 0xCA, 0xFF, 0x34 },
    { 0xD3, 0xFF, 0x55 },
    { 0xDC, 0xFF, 0x77 },
    { 0xE4, 0xFF, 0x99 },
    { 0xED, 0xFF, 0xBB },
    { 0xF6, 0xFF, 0xDD },
    { 0x18, 0x33, 0x1A },
    { 0x31, 0x66, 0x34 },
    { 0x49, 0x98, 0x4F },
    { 0x62, 0xCC, 0x69 },
    { 0x7A, 0xFF, 0x84 },
    { 0x90, 0xFF, 0x98 },
    { 0xA6, 0xFF, 0xAD },
    { 0xBC, 0xFF, 0xC1 },
    { 0xD2, 0xFF, 0xD6 },
    { 0xE8, 0xFF, 0xEA },
    { 0x08, 0x33, 0x2A },
    { 0x10, 0x66, 0x55 },
    { 0x19, 0x98, 0x7F },
    { 0x21, 0xCC, 0xAA },
    { 0x2A, 0xFF, 0xD4 },
    { 0x4D, 0xFF, 0xDB },
    { 0x71, 0xFF, 0xE2 },
    { 0x94, 0xFF, 0xE9 },
    { 0xB8, 0xFF, 0xF0 },
    { 0xDB, 0xFF, 0xF7 },
    { 0x00, 0x2B, 0x33 },
    { 0x00, 0x56, 0x66 },
    { 0x00, 0x82, 0x98 },
    { 0x00, 0xAD, 0xCC },
    { 0x00, 0xD8, 0xFF },
    { 0x2A, 0xDF, 0xFF },
    { 0x55, 0xE5, 0xFF },
    { 0x7F, 0xEB, 0xFF },
    { 0xAA, 0xF2, 0xFF },
    { 0xD4, 0xF8, 0xFF },
    { 0x00, 0x1B, 0x33 },
    { 0x00, 0x36, 0x66 },
    { 0x00, 0x52, 0x98 },
    { 0x00, 0x6D, 0xCC },
    { 0x00, 0x88, 0xFF },
    { 0x2A, 0x9C, 0xFF },
    { 0x55, 0xB0, 0xFF },
    { 0x7F, 0xC3, 0xFF },
    { 0xAA, 0xD7, 0xFF },
    { 0xD4, 0xEB, 0xFF },
    { 0x00, 0x0B, 0x33 },
    { 0x00, 0x16, 0x66 },
    { 0x00, 0x21, 0x98 },
    { 0x00, 0x2D, 0xCC },
    { 0x00, 0x38, 0xFF },
    { 0x2A, 0x59, 0xFF },
    { 0x55, 0x7A, 0xFF },
    { 0x7F, 0x9B, 0xFF },
    { 0xAA, 0xBC, 0xFF },
    { 0xD4, 0xDD, 0xFF },
    { 0x04, 0x00, 0x33 },
    { 0x09, 0x00, 0x66 },
    { 0x0E, 0x00, 0x98 },
    { 0x13, 0x00, 0xCC },
    { 0x17, 0x00, 0xFF },
    { 0x3E, 0x2A, 0xFF },
    { 0x64, 0x55, 0xFF },
    { 0x8B, 0x7F, 0xFF },
    { 0xB1, 0xAA, 0xFF },
    { 0xD8, 0xD4, 0xFF },
    { 0x14, 0x00, 0x33 },
    { 0x29, 0x00, 0x66 },
    { 0x3E, 0x00, 0x98 },
    { 0x53, 0x00, 0xCC },
    { 0x68, 0x00, 0xFF },
    { 0x81, 0x2A, 0xFF },
    { 0x9A, 0x55, 0xFF },
    { 0xB3, 0x7F, 0xFF },
    { 0xCC, 0xAA, 0xFF },
    { 0xE5, 0xD4, 0xFF },
    { 0x24, 0x00, 0x33 },
    { 0x49, 0x00, 0x66 },
    { 0x6E, 0x00, 0x98 },
    { 0x93, 0x00, 0xCC },
    { 0xB8, 0x00, 0xFF },
    { 0xC4, 0x2A, 0xFF },
    { 0xD0, 0x55, 0xFF },
    { 0xDB, 0x7F, 0xFF },
    { 0xE7, 0xAA, 0xFF },
    { 0xF3, 0xD4, 0xFF },
    { 0x33, 0x00, 0x31 },
    { 0x66, 0x00, 0x62 },
    { 0x98, 0x00, 0x93 },
    { 0xCC, 0x00, 0xC4 },
    { 0xFF, 0x00, 0xF5 },
    { 0xFF, 0x2A, 0xF6 },
    { 0xFF, 0x55, 0xF8 },
    { 0xFF, 0x7F, 0xFA },
    { 0xFF, 0xAA, 0xFB },
    { 0xFF, 0xD4, 0xFD },
    { 0x33, 0x00, 0x20 },
    { 0x66, 0x00, 0x41 },
    { 0x98, 0x00, 0x62 },
    { 0xCC, 0x00, 0x83 },
    { 0xFF, 0x00, 0xA4 },
    { 0xFF, 0x2A, 0xB3 },
    { 0xFF, 0x55, 0xC2 },
    { 0xFF, 0x7F, 0xD1 },
    { 0xFF, 0xAA, 0xE0 },
    { 0xFF, 0xD4, 0xEF },
    { 0x33, 0x00, 0x10 },
    { 0x66, 0x00, 0x21 },
    { 0x98, 0x00, 0x32 },
    { 0xCC, 0x00, 0x43 },
    { 0xFF, 0x00, 0x54 },
    { 0xFF, 0x2A, 0x70 },
    { 0xFF, 0x55, 0x8D },
    { 0xFF, 0x7F, 0xA9 },
    { 0xFF, 0xAA, 0xC6 },
    { 0xFF, 0xD4, 0xE2 },
    { 0x33, 0x00, 0x00 },
    { 0x66, 0x00, 0x01 },
    { 0x98, 0x00, 0x02 },
    { 0xCC, 0x00, 0x03 },
    { 0xFF, 0x00, 0x04 },
    { 0xFF, 0x2A, 0x2E },
    { 0xFF, 0x55, 0x57 },
    { 0xFF, 0x7F, 0x81 },
    { 0xFF, 0xAA, 0xAB },
    { 0xFF, 0xD4, 0xD5 },
};

const int washTableEnts = sizeof(palWash) / 3;

////////////////////////////////////////////////////////////////////////

void GenerateColorWash(LPPALETTEENTRY pPE)
{
    int i;
    for (i = 0; i < washTableEnts; i++)
    {
        pPE->peRed   = palWash[i][0];
        pPE->peGreen = palWash[i][1];
        pPE->peBlue  = palWash[i][2];
        pPE->peFlags = 0;
        pPE++;
    }
    for (; i < 236; i++)
    {
        pPE->peRed   = 0;
        pPE->peGreen = 0;
        pPE->peBlue  = 0;
        pPE->peFlags = PC_RESERVED;
        pPE++;
    }
}

////////////////////////////////////////////////////////////////////////
#ifdef NEED_TO_CALC_WASH_TABLE
// The floowing routines where used to produce the spectral
// color wash for the color palette. The hard coded table is above.
// Only the entries outside of the system identity palette are
// given.

static void HSVtoRGB(double h, double s, double v, double *r,
    double *g, double *b);

void GenerateColorWash(LPPALETTEENTRY pPE)
{
    double  dh;
    double  r, g, b;

    // Generate a generic gray scale...

    for (int i = 0; i < numGraySteps; i++)
    {
        pPE->peRed = (i * 255) / (numGraySteps - 1);
        pPE->peGreen = (i * 255) / (numGraySteps - 1);
        pPE->peBlue = (i * 255) / (numGraySteps - 1);
        pPE->peFlags = 0;
        pPE++;
    }

    // This is the actual color wash...

    for (int h = 0; h < numHues; h++)
    {
        dh = 359.0 * h / (double)(numHues - 1);
        for (int v = 1; v < numHueVSteps + 1; v++)
        {
            HSVtoRGB(dh,  1.0, (double)v / numHueVSteps, &r, &g, &b);
            pPE->peRed = (int)(r * 255);
            pPE->peGreen = (int)(g * 255);
            pPE->peBlue = (int)(b * 255);
            pPE->peFlags = 0;
            pPE++;
        }
        for (int s = 1; s < numHueSSteps + 1; s++)
        {
            HSVtoRGB(dh, 1.0 - (double)s / (numHueSSteps + 1), 1.0, &r, &g, &b);
            pPE->peRed = (int)(r * 255);
            pPE->peGreen = (int)(g * 255);
            pPE->peBlue = (int)(b * 255);
            pPE->peFlags = 0;
            pPE++;
        }
    }
}

static void HSVtoRGB(double h, double s, double v, double *r,
    double *g, double *b)
{
    double f, p, q, t;
    int i;

    if (s == 0.0)
        *r = * g = *b = v;
    else
    {
        if (h >= 360.0)
            h = 0.0;
        h /= 60.0;
        i = (int)floor(h);
        f = h - i;
        p = v * (1.0 - s);
        q = v * (1.0 - s * f);
        t = v * (1.0 - s * (1.0 - f));
        switch (i)
        {
            case 0: *r = v; *g = t; *b = p; break;
            case 1: *r = q; *g = v; *b = p; break;
            case 2: *r = q; *g = v; *b = t; break;
            case 3: *r = p; *g = q; *b = v; break;
            case 4: *r = t; *g = p; *b = v; break;
            case 5: *r = v; *g = p; *b = q; break;
        }
    }
}

#endif

